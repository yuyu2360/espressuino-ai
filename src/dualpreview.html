<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Perfected Dual Gauge</title>
    <style>
        body {
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        .dual-gauge-container {
            position: relative;
            width: 340px;
            height: 340px;
        }

        .readout-overlay {
            position: absolute;
            top: 60px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
            z-index: 10;
            pointer-events: none;
        }

        .readout-group {
            display: flex;
            flex-direction: column;
        }
        
        .readout-left { text-align: right; }
        .readout-right { text-align: left; }

        .label {
            display: block;
            font-size: 11px;
            color: #94a3b8;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .value {
            display: block;
            font-size: 28px;
            font-weight: 700;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .unit {
            font-size: 14px;
            color: #94a3b8;
            margin-left: 2px;
        }

        .center-status {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .center-label {
            font-size: 11px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
        }
        
        .center-target {
            font-size: 18px;
            font-weight: 600;
            color: #e2e8f0;
        }

        /* IMPORTANT: Remove CSS transitions on stroke-dasharray to sync with JS loop */
        #maskPathTemp, #maskPathPress {
             /* transition: stroke-dasharray 0.1s linear; */
        }
    </style>
</head>
<body>

    <div class="dual-gauge-container">
        <div class="readout-overlay">
            <div class="readout-group readout-left">
                <span class="label">TEMP</span>
                <span class="value" id="tempVal">20.0<span class="unit">°C</span></span>
            </div>
            <div class="readout-group readout-right">
                <span class="label">PRESSURE</span>
                <span class="value" id="pressVal">0.0<span class="unit">bar</span></span>
            </div>
        </div>

        <svg width="340" height="340" style="filter: drop-shadow(0 4px 12px rgba(0,0,0,0.5));">
            <defs>
                <!-- Gradients: Using solid colors instead of opacity to fix "dark base" issue -->
                <linearGradient id="gradTemp" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" stop-color="#1e40af" /> <!-- Deep Blue -->
                    <stop offset="40%" stop-color="#3b82f6" /> <!-- Mid Blue -->
                    <stop offset="100%" stop-color="#93c5fd" /> <!-- Bright Blue -->
                </linearGradient>
                <linearGradient id="gradPress" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" stop-color="#991b1b" /> <!-- Deep Red -->
                    <stop offset="40%" stop-color="#ef4444" /> <!-- Mid Red -->
                    <stop offset="100%" stop-color="#fca5a5" /> <!-- Bright Red -->
                </linearGradient>
                
                <mask id="maskTemp">
                    <path id="maskPathTemp" fill="none" stroke="white" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" />
                </mask>
                
                <mask id="maskPress">
                    <path id="maskPathPress" fill="none" stroke="white" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" />
                </mask>
            </defs>

            <!-- LEFT GAUGE (TEMP) -->
            <path id="bgTemp" fill="none" stroke="#1e293b" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" />
            <path id="fillTemp" fill="none" stroke="url(#gradTemp)" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" mask="url(#maskTemp)" />

            <!-- RIGHT GAUGE (PRESSURE) -->
            <path id="bgPress" fill="none" stroke="#1e293b" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" />
            <path id="fillPress" fill="none" stroke="url(#gradPress)" stroke-width="24" stroke-dasharray="5 7" stroke-linecap="butt" mask="url(#maskPress)" />
        </svg>

        <div class="center-status">
            <div class="center-label">TARGET</div>
            <div class="center-target">93° <span style="color:#475569">|</span> 9 bar</div>
        </div>
    </div>

    <script>
        const radius = 130;
        const center = 170; 
        
        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        function describeArc(x, y, radius, startAngle, endAngle, sweepFlag) {
            var start = polarToCartesian(x, y, radius, endAngle);
            var end = polarToCartesian(x, y, radius, startAngle);
            var largeArcFlag = Math.abs(endAngle - startAngle) <= 180 ? "0" : "1";
            
            // Recalculate start/end points for SVG command
            var startPoint = polarToCartesian(x, y, radius, startAngle);
            var endPoint = polarToCartesian(x, y, radius, endAngle);

            return [
                "M", startPoint.x, startPoint.y, 
                "A", radius, radius, 0, largeArcFlag, sweepFlag, endPoint.x, endPoint.y
            ].join(" ");
        }
        
        // --- GEOMETRY SETUP ---
        // Left (Temp): 210 -> 330 (Clockwise, Sweep Flag 1)
        const leftPathFull = describeArc(center, center, radius, 210, 330, 1);
        document.getElementById('bgTemp').setAttribute('d', leftPathFull);
        document.getElementById('fillTemp').setAttribute('d', leftPathFull);
        document.getElementById('maskPathTemp').setAttribute('d', leftPathFull);
        
        // Right (Pressure): 150 -> 30 (Counter-Clockwise, Sweep Flag 0)
        const rightPathFull = describeArc(center, center, radius, 150, 30, 0);
        document.getElementById('bgPress').setAttribute('d', rightPathFull);
        document.getElementById('fillPress').setAttribute('d', rightPathFull);
        document.getElementById('maskPathPress').setAttribute('d', rightPathFull);

        // Calculate Lengths
        const leftLen = document.getElementById('bgTemp').getTotalLength();
        const rightLen = document.getElementById('bgPress').getTotalLength();

        // Initialize masks to hidden
        document.getElementById('maskPathTemp').style.strokeDasharray = `0 ${leftLen}`;
        document.getElementById('maskPathPress').style.strokeDasharray = `0 ${rightLen}`;

        // QUANTIZE FUNCTION
        // Ensures we fill complete segments (5px dash + 7px gap = 12px stride)
        function quantizeLength(rawLength, stride = 12) {
             const segments = Math.floor(rawLength / stride);
             return segments * stride;
             // Or allow partial fill of the dash but not the gap?
             // Simpler: Just raw length. The mask handles the gaps naturally.
             // If it "looks" missing, it might be because the value is just barely not enough to reach the next dash.
        }

        function updateGaugeVisuals(tempPct, pressPct) {
            const leftVisible = leftLen * tempPct;
            // Add tiny buffer to ensure top segment lights up fully at 100%
            const leftFinal = tempPct >= 0.99 ? leftLen : leftVisible;
            document.getElementById('maskPathTemp').style.strokeDasharray = `${leftFinal} ${leftLen}`;
            
            const rightVisible = rightLen * pressPct;
            const rightFinal = pressPct >= 0.99 ? rightLen : rightVisible;
            document.getElementById('maskPathPress').style.strokeDasharray = `${rightFinal} ${rightLen}`;
        }

        // --- ANIMATION LOOP ---
        let simTemp = 20;
        let simPress = 0;
        let direction = 1;

        function animate() {
            if(direction === 1) {
                simTemp += 0.5;
                simPress += 0.05; 
                if(simTemp > 120) direction = -1; // Go all the way to max
            } else {
                simTemp -= 0.5;
                simPress -= 0.05;
                if(simTemp < 20) direction = 1;
            }

            document.getElementById('tempVal').innerHTML = simTemp.toFixed(1) + '<span class="unit">°C</span>';
            document.getElementById('pressVal').innerHTML = simPress.toFixed(1) + '<span class="unit">bar</span>';

            const tempPct = Math.min(1, Math.max(0, (simTemp - 20) / (120 - 20)));
            const pressPct = Math.min(1, Math.max(0, (simPress - 0) / (12 - 0)));

            updateGaugeVisuals(tempPct, pressPct);
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>